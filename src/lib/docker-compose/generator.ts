import type { DockerComposeConfig } from './types';
import { REGISTRIES, ZAI_API_URL } from './types';

/**
 * Generate Docker Compose YAML configuration
 * @param config The configuration object
 * @returns Generated YAML string
 */
export function generateYAML(config: DockerComposeConfig): string {
  const lines: string[] = [];

  // Header comment
  lines.push('# Hagicode Docker Compose Configuration');
  lines.push('# Auto-generated by Docker Compose Generator');
  lines.push(`# Generated at: ${new Date().toLocaleString('zh-CN')}`);
  lines.push('');

  // Services section
  lines.push('services:');
  lines.push('  hagicode:');
  const imagePrefix = REGISTRIES[config.imageRegistry].imagePrefix;
  lines.push(`    image: ${imagePrefix}:${config.imageTag}`);
  lines.push(`    container_name: ${config.containerName}`);
  lines.push('    environment:');
  lines.push(`      ASPNETCORE_ENVIRONMENT: ${config.aspNetEnvironment}`);
  lines.push('      ASPNETCORE_URLS: http://+:45000');
  lines.push(`      TZ: ${config.timezone}`);

  // Database connection string
  if (config.databaseType === 'internal') {
    lines.push(`      ConnectionStrings__Default: "Host=postgres;Port=5432;Database=${config.postgresDatabase};Username=${config.postgresUser};Password=${config.postgresPassword}"`);
  } else {
    lines.push(`      ConnectionStrings__Default: "Host=${config.externalDbHost};Port=${config.externalDbPort};Database=${config.postgresDatabase};Username=${config.postgresUser};Password=${config.postgresPassword}"`);
  }

  lines.push(`      License__Activation__LicenseKey: "${config.licenseKey}"`);

  // User mapping for Linux
  if (config.hostOS === 'linux' && !config.workdirCreatedByRoot && (config.puid || config.pgid)) {
    lines.push(`      PUID: ${config.puid}`);
    lines.push(`      PGID: ${config.pgid}`);
  }

  // Claude API Configuration - unified use of ANTHROPIC_AUTH_TOKEN
  lines.push('      # ==================================================');
  lines.push('      # Claude Code Configuration');
  lines.push('      # All providers use ANTHROPIC_AUTH_TOKEN');
  lines.push('      # ANTHROPIC_URL is set for ZAI and custom providers');
  lines.push('      # ==================================================');

  switch (config.anthropicApiProvider) {
    case 'anthropic':
      if (config.anthropicAuthToken) {
        lines.push('      # Anthropic Official API');
        lines.push(`      ANTHROPIC_AUTH_TOKEN: "${config.anthropicAuthToken}"`);
        lines.push('      # No ANTHROPIC_URL needed - uses default Anthropic endpoint');
      }
      break;

    case 'zai':
      if (config.anthropicAuthToken) {
        lines.push('      # Zhipu AI (ZAI) - uses Anthropic-compatible API');
        lines.push(`      ANTHROPIC_AUTH_TOKEN: "${config.anthropicAuthToken}"`);
        lines.push(`      ANTHROPIC_URL: "${ZAI_API_URL}"`);
        lines.push('      # API Provider: Zhipu AI (ZAI)');
      }
      break;

    case 'custom':
      if (config.anthropicAuthToken) {
        lines.push('      # Custom Anthropic-compatible API');
        lines.push(`      ANTHROPIC_AUTH_TOKEN: "${config.anthropicAuthToken}"`);
        if (config.anthropicUrl) {
          lines.push(`      ANTHROPIC_URL: "${config.anthropicUrl}"`);
        }
        lines.push('      # API Provider: Custom Endpoint');
      }
      break;
  }

  lines.push('    ports:');
  lines.push(`      - "${config.httpPort}:45000"`);
  lines.push('    volumes:');

  // Work directory mapping
  if (config.hostOS === 'windows') {
    lines.push(`      - ${config.workdirPath || 'C:\\\\repos'}:/app/workdir`);
  } else {
    lines.push(`      - ${config.workdirPath || '/home/user/repos'}:/app/workdir`);
  }

  // Depends on
  if (config.databaseType === 'internal') {
    lines.push('    depends_on:');
    lines.push('      postgres:');
    lines.push('        condition: service_healthy');
  }

  lines.push('    networks:');
  lines.push('      - pcode-network');
  lines.push('    restart: unless-stopped');

  // Internal PostgreSQL service
  if (config.databaseType === 'internal') {
    lines.push('');
    lines.push('  postgres:');
    lines.push('    image: bitnami/postgresql:latest');
    lines.push('    environment:');
    lines.push(`      POSTGRES_DATABASE: ${config.postgresDatabase}`);
    lines.push(`      POSTGRES_USER: ${config.postgresUser}`);
    lines.push(`      POSTGRES_PASSWORD: ${config.postgresPassword}`);
    lines.push('      POSTGRES_HOST_AUTH_METHOD: trust');
    lines.push(`      TZ: ${config.timezone}`);
    lines.push('    volumes:');

    if (config.volumeType === 'named') {
      const volName = config.volumeName || 'postgres-data';
      lines.push(`      - ${volName}:/bitnami/postgresql`);
    } else {
      const defaultPath = config.hostOS === 'windows' ? 'C:\\\\data\\\\postgres' : '/data/postgres';
      lines.push(`      - ${config.volumePath || defaultPath}:/bitnami/postgresql`);
    }

    lines.push('    healthcheck:');
    lines.push(`      test: ["CMD", "pg_isready", "-U", "${config.postgresUser}"]`);
    lines.push('      interval: 10s');
    lines.push('      timeout: 3s');
    lines.push('      retries: 3');
    lines.push('    networks:');
    lines.push('      - pcode-network');
    lines.push('    restart: unless-stopped');
  }

  // Volumes section
  if (config.databaseType === 'internal' && config.volumeType === 'named') {
    const volName = config.volumeName || 'postgres-data';
    lines.push('');
    lines.push('volumes:');
    lines.push(`  ${volName}:`);
  }

  // Networks section
  lines.push('');
  lines.push('networks:');
  lines.push('  pcode-network:');
  lines.push('    driver: bridge');

  return lines.join('\n');
}

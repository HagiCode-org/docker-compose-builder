import type { DockerComposeConfig } from './types';
import { REGISTRIES, ZAI_API_URL } from './types';

/**
 * Build header comment section
 * @param _config The configuration object (unused but kept for consistency)
 * @param language The language code (e.g., 'zh-CN', 'en-US')
 * @param now The current date/time (for testability)
 * @returns Array of header comment lines
 */
export function buildHeader(
  _config: DockerComposeConfig,
  language: string,
  now: Date
): string[] {
  const lines: string[] = [];

  // Support information based on language
  const supportInfo = language === 'zh-CN' ? {
    title: '支持信息',
    description: '如果您遇到任何问题或需要技术支持:',
    qqGroup: '加入我们的 QQ 群',
    qqNumber: '610394020',
    assistance: '我们提供实时协助和解决方案',
    share: '分享您的经验并与其他用户交流'
  } : {
    title: 'Support Information',
    description: 'If you encounter any issues or need technical support:',
    qqGroup: 'Join our QQ group',
    qqNumber: '610394020',
    assistance: 'We provide real-time assistance and solutions',
    share: 'Share your experiences and connect with other users'
  };

  // Header comment
  lines.push('# Hagicode Docker Compose Configuration');
  lines.push('# Auto-generated by Docker Compose Generator');
  lines.push(`# Generated at: ${now.toLocaleString(language === 'zh-CN' ? 'zh-CN' : 'en-US', { timeZone: 'UTC' })}`);
  lines.push('');
  lines.push('# ==================================================');
  lines.push(`# ${supportInfo.title}`);
  lines.push('# ==================================================');
  lines.push(`# ${supportInfo.description}`);
  lines.push(`# - ${supportInfo.qqGroup}: ${supportInfo.qqNumber}`);
  lines.push(`# - ${supportInfo.assistance}`);
  lines.push(`# - ${supportInfo.share}`);
  lines.push('');

  return lines;
}

/**
 * Build application service (hagicode) configuration
 * @param config The configuration object
 * @returns Array of app service configuration lines
 */
export function buildAppService(config: DockerComposeConfig): string[] {
  const lines: string[] = [];

  lines.push('  hagicode:');
  const imagePrefix = REGISTRIES[config.imageRegistry].imagePrefix;
  let appImage: string;

  if (config.imageRegistry === 'aliyun-acr') {
    appImage = `${imagePrefix}/hagicode:${config.imageTag}`;
  } else {
    appImage = `${imagePrefix}:${config.imageTag}`;
  }

  lines.push(`    image: ${appImage}`);
  lines.push(`    container_name: ${config.containerName}`);
  lines.push('    environment:');
  lines.push(`      ASPNETCORE_ENVIRONMENT: ${config.aspNetEnvironment}`);
  lines.push('      ASPNETCORE_URLS: http://+:45000');
  lines.push(`      TZ: ${config.timezone}`);

  // Database connection string
  if (config.databaseType === 'internal') {
    lines.push(`      ConnectionStrings__Default: "Host=postgres;Port=5432;Database=${config.postgresDatabase};Username=${config.postgresUser};Password=${config.postgresPassword}"`);
  } else {
    lines.push(`      ConnectionStrings__Default: "Host=${config.externalDbHost};Port=${config.externalDbPort};Database=${config.postgresDatabase};Username=${config.postgresUser};Password=${config.postgresPassword}"`);
  }

  lines.push(`      License__Activation__LicenseKey: "${config.licenseKey}"`);

  // User mapping for Linux
  if (config.hostOS === 'linux' && !config.workdirCreatedByRoot && (config.puid || config.pgid)) {
    lines.push(`      PUID: ${config.puid}`);
    lines.push(`      PGID: ${config.pgid}`);
  }

  // Claude API Configuration - unified use of ANTHROPIC_AUTH_TOKEN
  lines.push('      # ==================================================');
  lines.push('      # Claude Code Configuration');
  lines.push('      # All providers use ANTHROPIC_AUTH_TOKEN');
  lines.push('      # ANTHROPIC_URL is set for ZAI and custom providers');
  lines.push('      # ==================================================');

  switch (config.anthropicApiProvider) {
    case 'anthropic':
      if (config.anthropicAuthToken) {
        lines.push('      # Anthropic Official API');
        lines.push(`      ANTHROPIC_AUTH_TOKEN: "${config.anthropicAuthToken}"`);
        lines.push('      # No ANTHROPIC_URL needed - uses default Anthropic endpoint');
      }
      break;

    case 'zai':
      if (config.anthropicAuthToken) {
        lines.push('      # Zhipu AI (ZAI) - uses Anthropic-compatible API');
        lines.push(`      ANTHROPIC_AUTH_TOKEN: "${config.anthropicAuthToken}"`);
        lines.push(`      ANTHROPIC_URL: "${ZAI_API_URL}"`);
        lines.push('      # API Provider: Zhipu AI (ZAI)');
      }
      break;

    case 'custom':
      if (config.anthropicAuthToken) {
        lines.push('      # Custom Anthropic-compatible API');
        lines.push(`      ANTHROPIC_AUTH_TOKEN: "${config.anthropicAuthToken}"`);
        if (config.anthropicUrl) {
          lines.push(`      ANTHROPIC_URL: "${config.anthropicUrl}"`);
        }
        lines.push('      # API Provider: Custom Endpoint');
      }
      break;
  }

  lines.push('    ports:');
  lines.push(`      - "${config.httpPort}:45000"`);
  lines.push('    volumes:');

  // Work directory mapping
  if (config.hostOS === 'windows') {
    lines.push(`      - ${config.workdirPath || 'C:\\\\repos'}:/app/workdir`);
  } else {
    lines.push(`      - ${config.workdirPath || '/home/user/repos'}:/app/workdir`);
  }

  // Depends on
  if (config.databaseType === 'internal') {
    lines.push('    depends_on:');
    lines.push('      postgres:');
    lines.push('        condition: service_healthy');
  }

  lines.push('    networks:');
  lines.push('      - pcode-network');
  lines.push('    restart: unless-stopped');

  return lines;
}

/**
 * Build PostgreSQL service configuration
 * @param config The configuration object
 * @returns Array of PostgreSQL service configuration lines
 */
export function buildPostgresService(config: DockerComposeConfig): string[] {
  const lines: string[] = [];

  const imagePrefix = REGISTRIES[config.imageRegistry].imagePrefix;
  let dbImage: string;

  if (config.imageRegistry === 'aliyun-acr') {
    dbImage = `${imagePrefix}/bitnami_postgresql:16`;
  } else {
    dbImage = 'bitnami/postgresql:latest';
  }

  lines.push('');
  lines.push('  postgres:');
  lines.push(`    image: ${dbImage}`);
  lines.push('    environment:');
  lines.push(`      POSTGRES_DATABASE: ${config.postgresDatabase}`);
  lines.push(`      POSTGRES_USER: ${config.postgresUser}`);
  lines.push(`      POSTGRES_PASSWORD: ${config.postgresPassword}`);
  lines.push('      POSTGRES_HOST_AUTH_METHOD: trust');
  lines.push(`      TZ: ${config.timezone}`);
  lines.push('    volumes:');

  if (config.volumeType === 'named') {
    const volName = config.volumeName || 'postgres-data';
    lines.push(`      - ${volName}:/bitnami/postgresql`);
  } else {
    const defaultPath = config.hostOS === 'windows' ? 'C:\\\\data\\\\postgres' : '/data/postgres';
    lines.push(`      - ${config.volumePath || defaultPath}:/bitnami/postgresql`);
  }

  lines.push('    healthcheck:');
  lines.push(`      test: ["CMD", "pg_isready", "-U", "${config.postgresUser}"]`);
  lines.push('      interval: 10s');
  lines.push('      timeout: 3s');
  lines.push('      retries: 3');
  lines.push('    networks:');
  lines.push('      - pcode-network');
  lines.push('    restart: unless-stopped');

  return lines;
}

/**
 * Build services section
 * @param config The configuration object
 * @returns Array of services section lines
 */
export function buildServicesSection(config: DockerComposeConfig): string[] {
  const lines: string[] = [];

  lines.push('services:');

  // Add app service
  const appServiceLines = buildAppService(config);
  lines.push(...appServiceLines);

  // Add internal PostgreSQL service if needed
  if (config.databaseType === 'internal') {
    const postgresServiceLines = buildPostgresService(config);
    lines.push(...postgresServiceLines);
  }

  return lines;
}

/**
 * Build volumes section
 * @param config The configuration object
 * @returns Array of volumes section lines
 */
export function buildVolumesSection(config: DockerComposeConfig): string[] {
  const lines: string[] = [];

  if (config.databaseType === 'internal' && config.volumeType === 'named') {
    const volName = config.volumeName || 'postgres-data';
    lines.push('');
    lines.push('volumes:');
    lines.push(`  ${volName}:`);
  }

  return lines;
}

/**
 * Build networks section
 * @param _config The configuration object (unused but kept for consistency)
 * @returns Array of networks section lines
 */
export function buildNetworksSection(_config: DockerComposeConfig): string[] {
  const lines: string[] = [];

  lines.push('');
  lines.push('networks:');
  lines.push('  pcode-network:');
  lines.push('    driver: bridge');

  return lines;
}

/**
 * Generate Docker Compose YAML configuration
 * @param config The configuration object
 * @param language The language code (e.g., 'zh-CN', 'en-US')
 * @param now The current date/time (for testability, defaults to current time)
 * @returns Generated YAML string
 */
export function generateYAML(
  config: DockerComposeConfig,
  language: string = 'zh-CN',
  now: Date = new Date()
): string {
  const lines: string[] = [];

  // Build header
  const headerLines = buildHeader(config, language, now);
  lines.push(...headerLines);

  // Build services section
  const servicesLines = buildServicesSection(config);
  lines.push(...servicesLines);

  // Build volumes section
  const volumesLines = buildVolumesSection(config);
  lines.push(...volumesLines);

  // Build networks section
  const networksLines = buildNetworksSection(config);
  lines.push(...networksLines);

  return lines.join('\n');
}
